"use strict";(self.webpackChunkbrain_blog=self.webpackChunkbrain_blog||[]).push([[8749],{1895:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/dunder-methods","metadata":{"permalink":"/blog/dunder-methods","editUrl":"https://github.com/tchez/brain-blog/edit/main/blog/2025-06-11-dunder-methods.md","source":"@site/blog/2025-06-11-dunder-methods.md","title":"Do you know what magic methods are in Python? Hint: You use them every day!","description":"In this article, we will explore the fascinating world of magic methods in Python, their purpose, and how they can enhance your coding experience. Let\'s dive in!","date":"2025-06-11T00:00:00.000Z","tags":[{"inline":true,"label":"python","permalink":"/blog/tags/python"},{"inline":true,"label":"programming","permalink":"/blog/tags/programming"},{"inline":true,"label":"article","permalink":"/blog/tags/article"}],"readingTime":9.69,"hasTruncateMarker":true,"authors":[{"name":"Marco Ant\xf4nio Martins Porto Netto","title":"Full\u2011Stack Dev & AI\xa0Enthusiast","url":"https://github.com/tchez","imageURL":"https://github.com/tchez.png","key":"tchez","page":null}],"frontMatter":{"title":"Do you know what magic methods are in Python? Hint: You use them every day!","description":"In this article, we will explore the fascinating world of magic methods in Python, their purpose, and how they can enhance your coding experience. Let\'s dive in!","slug":"/dunder-methods","authors":["tchez"],"tags":["python","programming","article"],"image":"/img/blog/dunder-methods/article-og.png"},"unlisted":false,"nextItem":{"title":"Welcome to Brain\xa0Blog\xa0\ud83c\udf89","permalink":"/blog/welcome"}},"content":"![Dunder Methods](/img/blog/dunder-methods/article-og.png)\\n\\n## Do you know what magic methods are in Python? Hint: You use them every day!\\n\\nA few years ago, when I was learning to use the Django framework (the first framework I ever learned), I came across a peculiar characteristic of Python classes: the constructor method has to follow a specific pattern \u2014 it must be identified by double underscores (\\\\_\\\\_) before and after the word `init`. That struck me as odd; why this specific structure?\\n\\n\x3c!-- truncate --\x3e\\n\\n```python\\nclass MyClass:\\n    def __init__(self): # This is the constructor method\\n        ...\\n```\\n\\nTrying to understand where these \'different\' functions came from, I found out that in the world of Python, there are several methods that follow this \'dunder\' pattern (a nickname derived from Double UNDERscore). These methods aren\u2019t just common \u2014 they\u2019re special and fundamental to the language, known as dunder methods or magic methods.\\n\\nOK, but what do these methods actually do? What makes them \'magic\'?\\n\\nThose were some of the questions that led me to study them more deeply and write this article. Hope you enjoy it :)\\n\\n---\\n\\n## What are dunder methods?\\n\\nIn the world of programming, we often come across concepts that seem complex at first, but once understood, make perfect sense. A great example of this in Python is _dunder methods_.\\n\\nSo, what exactly are these methods? As mentioned earlier, the word \'dunder\' refers to the double underscore notation at the beginning and end of the names of these special methods. For instance, `__init__` for a class constructor, or `__str__` for the string representation of an object.\\n\\n> P.S. Some Python purists don\u2019t like calling the `__init__` method a constructor, since technically it\u2019s an initializer. However, for the sake of simplicity, we\u2019ll refer to it as a constructor throughout this article.\\n\\nThese methods aren\u2019t called directly by name. Instead, Python calls them internally when certain actions are performed. For example, when we add two objects using the `+` operator, Python internally calls the `__add__` method, which handles the logic of adding one value to another.\\n\\n> Still a bit confusing? Let me give you some examples to make it clearer!\\n\\nImagine you\'re building a class to represent a book in a library. To do that, you\u2019ll need to implement the `__init__` method, which acts as a constructor, setting up initial attributes like title, author, and page count:\\n\\n```python\\nclass Book:\\n    def __init__(self, title, author, pages):\\n        self.title = title\\n        self.author = author\\n        self.pages = pages\\n```\\n\\nWhat happens when you try to add two `Book` objects together? You might expect them to combine in some way, but Python doesn\'t know how to handle that operation by default:\\n\\n```python\\nbook1 = Book(\\"First Book\\", \\"Author A\\", 100)\\nbook2 = Book(\\"Second Book\\", \\"Author B\\", 200)\\n\\nprint(book1 + book2)\\n```\\n\\nThis will raise a `TypeError` because Python doesn\'t know how to add two `Book` objects together. This code will output:\\n\\n```python\\n>>> TypeError: unsupported operand type(s) for +: \'Book\' and \'Book\'\\n```\\n\\nTo make this operation work, you can define the `__add__` method in your `Book` class. This method will specify how two `Book` objects should be added together. For example, you might want to add their page counts:\\n\\n```python\\nclass Book:\\n    def __init__(self, title, author, pages):\\n        self.title = title\\n        self.author = author\\n        self.pages = pages\\n\\n    def __add__(self, other):\\n        return self.pages + other.pages\\n```\\n\\nNow, when you try to add two `Book` objects, Python will call the `__add__` method, in this case, summing their page counts. This is how you can customize the behavior of operators for your own classes.\\n\\n```python\\nbook1 = Book(\\"First Book\\", \\"Author A\\", 100)\\nbook2 = Book(\\"Second Book\\", \\"Author B\\", 200)\\n\\nprint(book1 + book2) # This will output: 300\\n```\\n\\n**This behavior isn\'t limited to just the addition operator!**\\n\\nActually, the most operators in Python can be customized using dunder methods. For example, you can define how your class behaves with the `==` operator by implementing the `__eq__` method, or with the `-` operator by implementing the `__sub__` method. A good example of this is the `in` operator, when we verify if some `value` is `in` a `list`, behind the scenes, Python is calling the `__contains__` method of the list class, passing the `value` as an argument. See the example below:\\n\\n```python\\nmy_list = [1, 2, 3, 4, 5]\\n\\nprint(3 in my_list)  # This will output: True\\nprint(my_list.__contains__(3))  # This will also output: True\\n\\nprint(6 in my_list)  # This will output: False\\nprint(my_list.__contains__(6))  # This will also output: False\\n```\\n\\n## More examples of dunder methods\\n\\nNow that you have a basic understanding of what dunder methods are and how they work, let\'s see some more examples of their usage, still applied to the `Book` class:\\n\\n### `__str__`: Customizing prints\\n\\nFollowing the previous example, what happens when you try to print a `Book` object? By default, Python will show something like `<__main__.Book object at 0x...>`, which isn\'t very informative:\\n\\n```python\\nbook1 = Book(\\"First Book\\", \\"Author A\\", 100)\\nprint(book1)\\n```\\n\\nThis will output something like:\\n\\n```python\\n>>> <__main__.Book object at 0x7f8c1b0d0>\\n```\\n\\nIf you\'re wondering whether it\'s possible to customize this output, making the representation more user-friendly, yes, it is! You just need to implement the magic method called `__str__` in your class. This method allows you to define how your object should be represented as a _string_. So, let\'s go ahead and implement it:\\n\\n```python\\nclass Book:\\n    def __init__(self, title, author, pages):\\n        self.title = title\\n        self.author = author\\n        self.pages = pages\\n\\n    def __str__(self):\\n        return f\\"{self.title} by {self.author}, {self.pages} pages\\"\\n```\\n\\nNow, when you print a `Book` object, it will display the title, author, and page count in a more readable format:\\n\\n```python\\nbook1 = Book(\\"First Book\\", \\"Author A\\", 100)\\nprint(book1) # This will output: First Book by Author A, 100 pages\\n```\\n\\n### `__eq__`: Customizing equality checks\\n\\nWhat if you want to check if two `Book` objects are considered equal? By default, Python checks if they are the same object in memory, which might not be what you want. To customize this behavior, you can implement the `__eq__` method:\\n\\n```python\\nclass Book:\\n    def __init__(self, title, author, pages):\\n        self.title = title\\n        self.author = author\\n        self.pages = pages\\n\\n    def __eq__(self, other):\\n        return (self.title == other.title and\\n                self.author == other.author and\\n                self.pages == other.pages)\\n```\\n\\nNow, you can compare two `Book` objects for equality based on their attributes:\\n\\n```python\\nbook1 = Book(\\"First Book\\", \\"Author A\\", 100)\\nbook2 = Book(\\"Second Book\\", \\"Author B\\", 200)\\nbook3 = Book(\\"First Book\\", \\"Author A\\", 100)\\n\\nprint(book1 == book2)  # This will output: False\\nprint(book1 == book3)  # This will output: True\\nprint(book3.__eq__(book1))  # This will output: True\\n```\\n\\n### `__len__`: Customizing length checks\\n\\nWhat if you want to check how many pages a book has? You can manually check the `pages` attribute, but you can also implement the `__len__` method to allow the use of the built-in `len()` function:\\n\\n```python\\nclass Book:\\n    def __init__(self, title, author, pages):\\n        self.title = title\\n        self.author = author\\n        self.pages = pages\\n\\n    def __len__(self):\\n        return self.pages\\n```\\n\\nNow, you can use the `len()` function on a `Book` object:\\n\\n```python\\nbook1 = Book(\\"First Book\\", \\"Author A\\", 100)\\nprint(len(book1))  # This will output: 100\\n```\\n\\n### `__getitem__`: Customizing item access\\n\\nLastly, what if you want to access a specific attribute of a `Book` object using indexing, like `book[0]` for the title? You can implement the `__getitem__` method:\\n\\n```python\\nclass Book:\\n    def __init__(self, title, author, pages):\\n        self.title = title\\n        self.author = author\\n        self.pages = pages\\n\\n    def __getitem__(self, index):\\n        if index == 0:\\n            return self.title\\n        elif index == 1:\\n            return self.author\\n        elif index == 2:\\n            return self.pages\\n        else:\\n            raise IndexError(\\"Index out of range\\")\\n```\\n\\nNow, you can access the title, author, and pages of a `Book` object using indexing:\\n\\n```python\\nbook1 = Book(\\"First Book\\", \\"Author A\\", 100)\\nprint(book1[0])  # This will output: First Book\\nprint(book1[1])  # This will output: Author A\\nprint(book1[2])  # This will output: 100\\n```\\n\\n## Conclusion\\n\\nThese were just a few examples that highlight the power and flexibility of dunder methods in Python. With them, you can shape the behavior of your classes and objects in ways that align with the language\'s syntax and paradigms, making your code more intuitive and \'Pythonic\'.\\n\\nSo, next time you\'re designing a Python class, remember the magic of dunder methods and how they can enrich your abstractions!\\n\\nBellow, I\'ll leave a list of some of the most commonly used dunder methods in Python, each linked to the official documentation for further reading:\\n\\n- [`__init__`](https://docs.python.org/3/reference/datamodel.html#object.__init__): The constructor method, called when an object is created.\\n- [`__add__`](https://docs.python.org/3/reference/datamodel.html#object.__add__): Defines the behavior of the addition operator (`+`).\\n- [`__contains__`](https://docs.python.org/3/reference/datamodel.html#object.__contains__): Defines the behavior of the `in` operator for an object.\\n- [`__str__`](https://docs.python.org/3/reference/datamodel.html#object.__str__): Defines the string representation of an object, used by the `print()` function.\\n- [`__eq__`](https://docs.python.org/3/reference/datamodel.html#object.__eq__): Defines the behavior of the equality operator (`==`).\\n- [`__len__`](https://docs.python.org/3/reference/datamodel.html#object.__len__): Defines the behavior of the `len()` function for an object.\\n- [`__getitem__`](https://docs.python.org/3/reference/datamodel.html#object.__getitem__): Defines the behavior of indexing an object (e.g., `obj[key]`).\\n- [`__setitem__`](https://docs.python.org/3/reference/datamodel.html#object.__setitem__): Defines the behavior of setting an item in an object (e.g., `obj[key] = value`).\\n- [`__delitem__`](https://docs.python.org/3/reference/datamodel.html#object.__delitem__): Defines the behavior of deleting an item from an object (e.g., `del obj[key]`).\\n- [`__repr__`](https://docs.python.org/3/reference/datamodel.html#object.__repr__): Defines the official string representation of an object, used by the `repr()` function.\\n- [`__ne__`](https://docs.python.org/3/reference/datamodel.html#object.__ne__): Defines the behavior of the inequality operator (`!=`).\\n- [`__lt__`](https://docs.python.org/3/reference/datamodel.html#object.__lt__): Defines the behavior of the less than operator (`<`).\\n- [`__le__`](https://docs.python.org/3/reference/datamodel.html#object.__le__): Defines the behavior of the less than or equal to operator (`<=`).\\n- [`__gt__`](https://docs.python.org/3/reference/datamodel.html#object.__gt__): Defines the behavior of the greater than operator (`>`).\\n- [`__ge__`](https://docs.python.org/3/reference/datamodel.html#object.__ge__): Defines the behavior of the greater than or equal to operator (`>=`).\\n- [`__sub__`](https://docs.python.org/3/reference/datamodel.html#object.__sub__): Defines the behavior of the subtraction operator (`-`).\\n- [`__mul__`](https://docs.python.org/3/reference/datamodel.html#object.__mul__): Defines the behavior of the multiplication operator (`*`).\\n- [`__truediv__`](https://docs.python.org/3/reference/datamodel.html#object.__truediv__): Defines the behavior of the true division operator (`/`).\\n- [`__bool__`](https://docs.python.org/3/reference/datamodel.html#object.__bool__): Defines the truth value of an object, used by the `bool()` function.\\n- [`__iter__`](https://docs.python.org/3/reference/datamodel.html#object.__iter__): Defines the behavior of an object when used in a loop or with the `iter()` function.\\n- [`__next__`](https://docs.python.org/3/reference/datamodel.html#object.__next__): Defines the behavior of the `next()` function for an object, allowing it to be iterable.\\n- [`__enter__`](https://docs.python.org/3/reference/datamodel.html#object.__enter__): Defines the behavior of an object when used in a `with` statement, allowing it to set up a context.\\n- [`__exit__`](https://docs.python.org/3/reference/datamodel.html#object.__exit__): Defines the behavior of an object when exiting a `with` statement, allowing it to clean up resources.\\n- [`__hash__`](https://docs.python.org/3/reference/datamodel.html#object.__hash__): Defines the behavior of the `hash()` function for an object, allowing it to be used in hash-based collections like sets and dictionaries.\\n- [`__del__`](https://docs.python.org/3/reference/datamodel.html#object.__del__): Defines the behavior of an object when it is about to be destroyed, allowing for cleanup actions.\\n\\nI hope this article has shed some light on the fascinating world of dunder methods in Python. If you have any questions or want to share your experiences with dunder methods, feel free to get in touch! Happy coding!\\n\\n## References\\n\\n- [Python Official Documentation - Data Model](https://docs.python.org/3/reference/datamodel.html)\\n- [Dunder methods | Pydon\'t \ud83d\udc0d](https://mathspp.com/blog/pydonts/dunder-methods)\\n- [Dunder methods in Python, really crazy functions](https://nitesh-yadav.medium.com/dunder-methods-in-python-really-crazy-functions-3455ecb6472d)"},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/tchez/brain-blog/edit/main/blog/2025-05-04-welcome.md","source":"@site/blog/2025-05-04-welcome.md","title":"Welcome to Brain\xa0Blog\xa0\ud83c\udf89","description":"My personal place to share ideas and dump structured knowledge.","date":"2025-05-04T00:00:00.000Z","tags":[{"inline":true,"label":"blog","permalink":"/blog/tags/blog"}],"readingTime":1.03,"hasTruncateMarker":true,"authors":[{"name":"Marco Ant\xf4nio Martins Porto Netto","title":"Full\u2011Stack Dev & AI\xa0Enthusiast","url":"https://github.com/tchez","imageURL":"https://github.com/tchez.png","key":"tchez","page":null}],"frontMatter":{"title":"Welcome to Brain\xa0Blog\xa0\ud83c\udf89","description":"My personal place to share ideas and dump structured knowledge.","slug":"welcome","authors":["tchez"],"tags":["blog"],"image":"/img/logo-og.png","keywords":["brain blog","second brain","knowledge vault","learning","study notes"]},"unlisted":false,"prevItem":{"title":"Do you know what magic methods are in Python? Hint: You use them every day!","permalink":"/blog/dunder-methods"}},"content":"![Brain\xa0Blog](/img/logo-og.png)\\n\\nHello, world! \ud83d\udc4b\\n\\n\x3c!-- TODO: Adicionar link para o about me depois --\x3e\\n\\nI\u2019m **[Marco\xa0Ant\xf4nio](https://www.linkedin.com/in/tchez)** and this is my **Brain\xa0Blog**.\\n\\nThis first post is a quick tour of what you\u2019ll find here.\\n\\n\x3c!-- truncate --\x3e\\n\\n### Why \u201cBrain\xa0Blog\u201d?\\n\\n> _\u201cThose who teach learn while teaching, and those who learn teach while learning.\u201d_\\n> \u2014 Paulo Freire (Translated from Portuguese)\\n\\nBrain\xa0Blog is a public backup of my brain where I capture study notes,\\norganize references and document learning journeys.\\n\\n### Content structure\\n\\nimport Tabs from \\"@theme/Tabs\\";\\nimport TabItem from \\"@theme/TabItem\\";\\n\\n<Tabs defaultValue=\\"blog\\">\\n  <TabItem value=\\"blog\\" label=\\"Blog\\">\\n    <br/>\\n    > My personal stream of ideas and experience.\\n    \\n    You\u2019ll read articles, tutorials and reflections on topics that excite me,\\n    plus lessons learned from real\u2011world projects.\\n  </TabItem>\\n  <TabItem value=\\"notes\\" label=\\"Notes\\">\\n    <br/>\\n    > A structured knowledge vault.\\n    \\n    I publish notes, summaries and references from everything I study,\\n    turning them into a reusable base.\\n    \\n    Notes are split into three sections:\\n    \\n    - **[Foundations](/notes/foundations/intro)** \u2013 core explanations of fundamentals (math, algorithms, protocols\u2026).\\n    - **[Projects](/notes/projects/intro)** \u2013 write\u2011ups of things I\u2019m building or ideas I\u2019m exploring.\\n    - **[Journeys](/notes/journeys/intro)** \u2013 step\u2011by\u2011step road\u2011maps of mastering a specific topic, linking to resources and notes.\\n  </TabItem>\\n</Tabs>"}]}}')}}]);